using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Collections.Generic;

namespace Chess
{
    /// <summary>
    /// NNUE (Efficiently Updatable Neural Network) loader and validator for chess evaluation
    /// Compatible with NNUE files generated by the Python training system
    /// </summary>
    public partial class NNUE
    {
        // NNUE file format constants
        private const uint NNUE_MAGIC = 0x454E4E55; // "NNUE" in little-endian
        private const uint EXPECTED_VERSION = 0x7AF32F16;
        private const uint EXPECTED_ARCHITECTURE = 177;

        // Network architecture constants (from Python training config)
        private const int INPUT_SIZE = 768;        // HalfKP features
        private const int HIDDEN_SIZE = 256;       // Hidden layer size
        private const int OUTPUT_SIZE = 1;         // Single evaluation output
        private const int FEATURE_TRANSFORMER_SIZE = 32; // Compressed features

        // Network parameters
        public string FilePath { get; private set; }
        public string Description { get; private set; }
        public bool IsLoaded { get; private set; }
        public DateTime LoadTime { get; private set; }

        // Network weights
        private float[,] featureTransformerWeights1;
        private float[] featureTransformerBias1;
        private float[,] featureTransformerWeights2;
        private float[] featureTransformerBias2;
        private float[,] outputLayerWeights1;
        private float[] outputLayerBias1;
        private float[,] outputLayerWeights2;
        private float[] outputLayerBias2;

        // Validation results
        public class ValidationResult
        {
            public bool IsValid { get; set; }
            public List<string> Errors { get; set; } = new List<string>();
            public List<string> Warnings { get; set; } = new List<string>();
            public Dictionary<string, object> Info { get; set; } = new Dictionary<string, object>();
        }

        /// <summary>
        /// Load an NNUE file from disk
        /// </summary>
        public ValidationResult LoadFromFile(string filePath)
        {
            var result = new ValidationResult();
            FilePath = filePath;
            IsLoaded = false;

            try
            {
                if (!File.Exists(filePath))
                {
                    result.Errors.Add($"File not found: {filePath}");
                    return result;
                }

                using (var reader = new BinaryReader(File.OpenRead(filePath)))
                {
                    // Read and validate header
                    if (!ReadAndValidateHeader(reader, result))
                    {
                        return result;
                    }

                    // Read network weights
                    if (!ReadNetworkWeights(reader, result))
                    {
                        return result;
                    }

                    // Validate network structure
                    ValidateNetworkStructure(result);

                    // If we got here, loading was successful
                    IsLoaded = result.Errors.Count == 0;
                    LoadTime = DateTime.Now;
                    result.IsValid = IsLoaded;

                    if (IsLoaded)
                    {
                        result.Info["FilePath"] = filePath;
                        result.Info["FileSize"] = new FileInfo(filePath).Length;
                        result.Info["LoadTime"] = LoadTime;
                        result.Info["Description"] = Description;
                    }
                }
            }
            catch (Exception ex)
            {
                result.Errors.Add($"Exception during loading: {ex.Message}");
                result.IsValid = false;
            }

            return result;
        }

        /// <summary>
        /// Read and validate NNUE file header
        /// </summary>
        private bool ReadAndValidateHeader(BinaryReader reader, ValidationResult result)
        {
            try
            {
                // Check file size
                long fileSize = reader.BaseStream.Length;
                if (fileSize < 16) // Minimum header size
                {
                    result.Errors.Add($"File too small: {fileSize} bytes");
                    return false;
                }

                // Read magic number
                byte[] magicBytes = reader.ReadBytes(4);
                uint magic = BitConverter.ToUInt32(magicBytes, 0);
                
                // Check if it's "NNUE" string
                string magicString = Encoding.ASCII.GetString(magicBytes);
                if (magicString != "NNUE")
                {
                    result.Errors.Add($"Invalid magic number. Expected 'NNUE', got '{magicString}'");
                    return false;
                }

                // Read version hash
                uint versionHash = reader.ReadUInt32();
                if (versionHash != EXPECTED_VERSION)
                {
                    result.Warnings.Add($"Version mismatch. Expected 0x{EXPECTED_VERSION:X8}, got 0x{versionHash:X8}");
                }
                result.Info["VersionHash"] = $"0x{versionHash:X8}";

                // Read architecture hash
                uint architectureHash = reader.ReadUInt32();
                if (architectureHash != EXPECTED_ARCHITECTURE)
                {
                    result.Warnings.Add($"Architecture mismatch. Expected {EXPECTED_ARCHITECTURE}, got {architectureHash}");
                }
                result.Info["ArchitectureHash"] = architectureHash;

                // Read description
                uint descriptionLength = reader.ReadUInt32();
                if (descriptionLength > 1024) // Sanity check
                {
                    result.Errors.Add($"Description length too large: {descriptionLength}");
                    return false;
                }

                byte[] descriptionBytes = reader.ReadBytes((int)descriptionLength);
                Description = Encoding.UTF8.GetString(descriptionBytes);
                result.Info["NetworkDescription"] = Description;

                // Parse architecture from description (e.g., "NNUE 768->256->1")
                if (Description.Contains("->"))
                {
                    string[] parts = Description.Split(' ')[1].Split(new[] { "->" }, StringSplitOptions.None);
                    if (parts.Length >= 2)
                    {
                        if (int.TryParse(parts[0], out int inputSize) && inputSize != INPUT_SIZE)
                        {
                            result.Warnings.Add($"Input size mismatch. Expected {INPUT_SIZE}, description shows {inputSize}");
                        }
                    }
                }

                return true;
            }
            catch (EndOfStreamException)
            {
                result.Errors.Add("Unexpected end of file while reading header");
                return false;
            }
        }

        /// <summary>
        /// Read network weights from the file
        /// </summary>
        private bool ReadNetworkWeights(BinaryReader reader, ValidationResult result)
        {
            try
            {
                // The Python export writes weights as float32 in native byte order
                // Based on the architecture: 768->256->32->32->1

                // Feature transformer layer 1: 768 -> 256
                featureTransformerWeights1 = ReadMatrix(reader, HIDDEN_SIZE, INPUT_SIZE);
                featureTransformerBias1 = ReadVector(reader, HIDDEN_SIZE);

                // Feature transformer layer 2: 256 -> 32
                featureTransformerWeights2 = ReadMatrix(reader, FEATURE_TRANSFORMER_SIZE, HIDDEN_SIZE);
                featureTransformerBias2 = ReadVector(reader, FEATURE_TRANSFORMER_SIZE);

                // Output layer 1: 32 -> 32
                outputLayerWeights1 = ReadMatrix(reader, FEATURE_TRANSFORMER_SIZE, FEATURE_TRANSFORMER_SIZE);
                outputLayerBias1 = ReadVector(reader, FEATURE_TRANSFORMER_SIZE);

                // Output layer 2: 32 -> 1
                outputLayerWeights2 = ReadMatrix(reader, OUTPUT_SIZE, FEATURE_TRANSFORMER_SIZE);
                outputLayerBias2 = ReadVector(reader, OUTPUT_SIZE);

                // Check if we've read the entire file
                long remainingBytes = reader.BaseStream.Length - reader.BaseStream.Position;
                if (remainingBytes > 0)
                {
                    result.Warnings.Add($"{remainingBytes} bytes remaining in file after reading weights");
                }

                result.Info["TotalParameters"] = CalculateTotalParameters();
                result.Info["MemoryUsageMB"] = CalculateMemoryUsage() / (1024.0 * 1024.0);

                return true;
            }
            catch (EndOfStreamException)
            {
                result.Errors.Add("Unexpected end of file while reading weights");
                return false;
            }
            catch (Exception ex)
            {
                result.Errors.Add($"Error reading weights: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Read a matrix of weights from the binary reader
        /// </summary>
        private float[,] ReadMatrix(BinaryReader reader, int rows, int cols)
        {
            float[,] matrix = new float[rows, cols];
            
            // Python writes in row-major order (C-style)
            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < cols; j++)
                {
                    matrix[i, j] = reader.ReadSingle();
                }
            }
            
            return matrix;
        }

        /// <summary>
        /// Read a vector of weights/biases from the binary reader
        /// </summary>
        private float[] ReadVector(BinaryReader reader, int size)
        {
            float[] vector = new float[size];
            
            for (int i = 0; i < size; i++)
            {
                vector[i] = reader.ReadSingle();
            }
            
            return vector;
        }

        /// <summary>
        /// Validate the loaded network structure
        /// </summary>
        private void ValidateNetworkStructure(ValidationResult result)
        {
            // Check for NaN or infinite values
            int nanCount = 0;
            int infCount = 0;
            float minWeight = float.MaxValue;
            float maxWeight = float.MinValue;

            // Check all weight matrices
            CheckWeightMatrix(featureTransformerWeights1, ref nanCount, ref infCount, ref minWeight, ref maxWeight);
            CheckWeightMatrix(featureTransformerWeights2, ref nanCount, ref infCount, ref minWeight, ref maxWeight);
            CheckWeightMatrix(outputLayerWeights1, ref nanCount, ref infCount, ref minWeight, ref maxWeight);
            CheckWeightMatrix(outputLayerWeights2, ref nanCount, ref infCount, ref minWeight, ref maxWeight);

            // Check all bias vectors
            CheckWeightVector(featureTransformerBias1, ref nanCount, ref infCount, ref minWeight, ref maxWeight);
            CheckWeightVector(featureTransformerBias2, ref nanCount, ref infCount, ref minWeight, ref maxWeight);
            CheckWeightVector(outputLayerBias1, ref nanCount, ref infCount, ref minWeight, ref maxWeight);
            CheckWeightVector(outputLayerBias2, ref nanCount, ref infCount, ref minWeight, ref maxWeight);

            if (nanCount > 0)
            {
                result.Errors.Add($"Found {nanCount} NaN values in weights");
            }

            if (infCount > 0)
            {
                result.Errors.Add($"Found {infCount} infinite values in weights");
            }

            result.Info["MinWeight"] = minWeight;
            result.Info["MaxWeight"] = maxWeight;
            result.Info["WeightRange"] = maxWeight - minWeight;

            // Check weight distribution
            if (Math.Abs(minWeight) > 10.0f || Math.Abs(maxWeight) > 10.0f)
            {
                result.Warnings.Add($"Weights have large magnitude: [{minWeight:F3}, {maxWeight:F3}]");
            }

            // Calculate weight statistics
            var stats = CalculateWeightStatistics();
            result.Info["MeanWeight"] = stats.Mean;
            result.Info["StdDevWeight"] = stats.StdDev;
        }

        /// <summary>
        /// Check a weight matrix for invalid values
        /// </summary>
        private void CheckWeightMatrix(float[,] matrix, ref int nanCount, ref int infCount, 
                                      ref float minWeight, ref float maxWeight)
        {
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < cols; j++)
                {
                    float value = matrix[i, j];
                    
                    if (float.IsNaN(value))
                        nanCount++;
                    else if (float.IsInfinity(value))
                        infCount++;
                    else
                    {
                        minWeight = Math.Min(minWeight, value);
                        maxWeight = Math.Max(maxWeight, value);
                    }
                }
            }
        }

        /// <summary>
        /// Check a weight vector for invalid values
        /// </summary>
        private void CheckWeightVector(float[] vector, ref int nanCount, ref int infCount,
                                      ref float minWeight, ref float maxWeight)
        {
            foreach (float value in vector)
            {
                if (float.IsNaN(value))
                    nanCount++;
                else if (float.IsInfinity(value))
                    infCount++;
                else
                {
                    minWeight = Math.Min(minWeight, value);
                    maxWeight = Math.Max(maxWeight, value);
                }
            }
        }

        /// <summary>
        /// Calculate total number of parameters in the network
        /// </summary>
        private int CalculateTotalParameters()
        {
            int total = 0;

            // Feature transformer
            total += INPUT_SIZE * HIDDEN_SIZE + HIDDEN_SIZE; // Layer 1
            total += HIDDEN_SIZE * FEATURE_TRANSFORMER_SIZE + FEATURE_TRANSFORMER_SIZE; // Layer 2

            // Output layers
            total += FEATURE_TRANSFORMER_SIZE * FEATURE_TRANSFORMER_SIZE + FEATURE_TRANSFORMER_SIZE; // Layer 1
            total += FEATURE_TRANSFORMER_SIZE * OUTPUT_SIZE + OUTPUT_SIZE; // Layer 2

            return total;
        }

        /// <summary>
        /// Calculate memory usage in bytes
        /// </summary>
        private long CalculateMemoryUsage()
        {
            // Each float is 4 bytes
            return CalculateTotalParameters() * 4L;
        }

        /// <summary>
        /// Calculate weight statistics
        /// </summary>
        private (float Mean, float StdDev) CalculateWeightStatistics()
        {
            List<float> allWeights = new List<float>();

            // Collect all weights
            AddMatrixToList(featureTransformerWeights1, allWeights);
            AddMatrixToList(featureTransformerWeights2, allWeights);
            AddMatrixToList(outputLayerWeights1, allWeights);
            AddMatrixToList(outputLayerWeights2, allWeights);
            
            allWeights.AddRange(featureTransformerBias1);
            allWeights.AddRange(featureTransformerBias2);
            allWeights.AddRange(outputLayerBias1);
            allWeights.AddRange(outputLayerBias2);

            // Calculate mean
            float mean = allWeights.Average();

            // Calculate standard deviation
            float variance = allWeights.Select(x => (x - mean) * (x - mean)).Average();
            float stdDev = (float)Math.Sqrt(variance);

            return (mean, stdDev);
        }

        /// <summary>
        /// Add matrix values to list for statistics
        /// </summary>
        private void AddMatrixToList(float[,] matrix, List<float> list)
        {
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < cols; j++)
                {
                    list.Add(matrix[i, j]);
                }
            }
        }

        /// <summary>
        /// Get a summary of the loaded NNUE model
        /// </summary>
        public string GetSummary()
        {
            if (!IsLoaded)
            {
                return "No NNUE model loaded";
            }

            var sb = new StringBuilder();
            sb.AppendLine("NNUE Model Summary");
            sb.AppendLine("==================");
            sb.AppendLine($"File: {Path.GetFileName(FilePath)}");
            sb.AppendLine($"Description: {Description}");
            sb.AppendLine($"Load Time: {LoadTime:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine($"Total Parameters: {CalculateTotalParameters():N0}");
            sb.AppendLine($"Memory Usage: {CalculateMemoryUsage() / (1024.0 * 1024.0):F2} MB");
            sb.AppendLine();
            sb.AppendLine("Network Architecture:");
            sb.AppendLine($"  Input Layer: {INPUT_SIZE} features (HalfKP)");
            sb.AppendLine($"  Hidden Layer 1: {HIDDEN_SIZE} neurons");
            sb.AppendLine($"  Hidden Layer 2: {FEATURE_TRANSFORMER_SIZE} neurons");
            sb.AppendLine($"  Output Layer: {OUTPUT_SIZE} neuron");

            return sb.ToString();
        }

        /// <summary>
        /// Validate multiple NNUE files and compare them
        /// </summary>
        public static Dictionary<string, ValidationResult> ValidateMultipleFiles(params string[] filePaths)
        {
            var results = new Dictionary<string, ValidationResult>();

            foreach (string filePath in filePaths)
            {
                var nnue = new NNUE();
                var result = nnue.LoadFromFile(filePath);
                results[filePath] = result;
            }

            return results;
        }

        /// <summary>
        /// Example usage and test method
        /// </summary>
        public static void TestNNUELoader()
        {
            Console.WriteLine("NNUE Loader Test");
            Console.WriteLine("================\n");

            // Example: Load a single NNUE file
            string nnuePath = @"models\chess_nnue_final.nnue";
            
            var nnue = new NNUE();
            var result = nnue.LoadFromFile(nnuePath);

            Console.WriteLine($"Loading: {nnuePath}");
            Console.WriteLine($"Valid: {result.IsValid}");

            if (result.Errors.Any())
            {
                Console.WriteLine("\nErrors:");
                foreach (var error in result.Errors)
                {
                    Console.WriteLine($"  - {error}");
                }
            }

            if (result.Warnings.Any())
            {
                Console.WriteLine("\nWarnings:");
                foreach (var warning in result.Warnings)
                {
                    Console.WriteLine($"  - {warning}");
                }
            }

            if (result.IsValid)
            {
                Console.WriteLine("\nModel Info:");
                foreach (var kvp in result.Info)
                {
                    Console.WriteLine($"  {kvp.Key}: {kvp.Value}");
                }

                Console.WriteLine("\n" + nnue.GetSummary());
            }

            // Example: Validate multiple files
            Console.WriteLine("\n\nValidating multiple files:");
            var multiResults = ValidateMultipleFiles(
                @"models\chess_nnue_best.pth",
                @"models\chess_nnue_epoch_10.pth",
                @"models\chess_nnue_final.nnue"
            );

            foreach (var kvp in multiResults)
            {
                Console.WriteLine($"\n{Path.GetFileName(kvp.Key)}: {(kvp.Value.IsValid ? "VALID" : "INVALID")}");
            }
        }
    }
}