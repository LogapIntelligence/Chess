using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Chess
{
    /// <summary>
    /// Global NNUE configuration
    /// </summary>
    public static class NNUEConfig
    {
        // Set your NNUE file path here
        public static string NNUEPath;

        // Enable/disable NNUE evaluation
        public static bool UseNNUE = true;
    }

    /// <summary>
    /// NNUE (Efficiently Updatable Neural Network) evaluator for chess positions
    /// Compatible with the NNUE format generated by the Python training system
    /// </summary>
    public class NNUEEvaluator : INNUEEvaluator
    {
        // Network architecture constants (must match your training configuration)
        private const int InputSize = 768;      // HalfKP features
        private const int HiddenSize1 = 256;    // First hidden layer
        private const int HiddenSize2 = 32;     // Second hidden layer
        private const float EvalScale = 361.0f; // Scaling factor from training

        // Network weights and biases
        private float[,] _featureTransformerWeights1;
        private float[] _featureTransformerBias1;
        private float[,] _featureTransformerWeights2;
        private float[] _featureTransformerBias2;
        private float[,] _outputWeights1;
        private float[] _outputBias1;
        private float[,] _outputWeights2;
        private float[] _outputBias2;

        // Feature encoding
        private readonly HalfKPFeatureEncoder _featureEncoder;

        // Path to NNUE file
        private readonly string _nnuePath;
        private bool _isLoaded = false;

        public NNUEEvaluator(string nnuePath)
        {
            _nnuePath = nnuePath;
            _featureEncoder = new HalfKPFeatureEncoder();
            LoadNNUE();
        }

        /// <summary>
        /// Load NNUE weights from file
        /// </summary>
        private void LoadNNUE()
        {
            try
            {
                using (var fs = new FileStream(_nnuePath, FileMode.Open, FileAccess.Read))
                using (var br = new BinaryReader(fs))
                {
                    // Read and verify header
                    byte[] magic = br.ReadBytes(4);
                    if (Encoding.ASCII.GetString(magic) != "NNUE")
                    {
                        throw new InvalidOperationException("Invalid NNUE file format");
                    }

                    uint versionHash = br.ReadUInt32();
                    uint architectureHash = br.ReadUInt32();

                    // Read description
                    int descriptionLength = br.ReadInt32();
                    byte[] descriptionBytes = br.ReadBytes(descriptionLength);
                    string description = Encoding.UTF8.GetString(descriptionBytes);
                    Console.WriteLine($"Loading NNUE model: {description}");

                    // Allocate arrays
                    _featureTransformerWeights1 = new float[HiddenSize1, InputSize];
                    _featureTransformerBias1 = new float[HiddenSize1];
                    _featureTransformerWeights2 = new float[HiddenSize2, HiddenSize1];
                    _featureTransformerBias2 = new float[HiddenSize2];
                    _outputWeights1 = new float[HiddenSize2, HiddenSize2];
                    _outputBias1 = new float[HiddenSize2];
                    _outputWeights2 = new float[1, HiddenSize2];
                    _outputBias2 = new float[1];

                    // Read feature transformer layer 1
                    ReadWeights(br, _featureTransformerWeights1);
                    ReadBias(br, _featureTransformerBias1);

                    // Read feature transformer layer 2
                    ReadWeights(br, _featureTransformerWeights2);
                    ReadBias(br, _featureTransformerBias2);

                    // Read output layer 1
                    ReadWeights(br, _outputWeights1);
                    ReadBias(br, _outputBias1);

                    // Read output layer 2
                    ReadWeights(br, _outputWeights2);
                    ReadBias(br, _outputBias2);

                    _isLoaded = true;
                    Console.WriteLine("NNUE model loaded successfully!");
                }
            }
            catch (FileNotFoundException)
            {
                Console.WriteLine($"NNUE file not found: {_nnuePath}");
                Console.WriteLine("Falling back to classical evaluation");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error loading NNUE: {ex.Message}");
                Console.WriteLine("Falling back to classical evaluation");
            }
        }

        /// <summary>
        /// Read weight matrix from binary reader
        /// </summary>
        private void ReadWeights(BinaryReader br, float[,] weights)
        {
            int rows = weights.GetLength(0);
            int cols = weights.GetLength(1);

            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < cols; j++)
                {
                    weights[i, j] = br.ReadSingle();
                }
            }
        }

        /// <summary>
        /// Read bias vector from binary reader
        /// </summary>
        private void ReadBias(BinaryReader br, float[] bias)
        {
            for (int i = 0; i < bias.Length; i++)
            {
                bias[i] = br.ReadSingle();
            }
        }

        /// <summary>
        /// Evaluate a chess position using NNUE
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Evaluate(ref Board board)
        {
            // Fall back to classical evaluation if NNUE not loaded
            if (!_isLoaded)
            {
                return Evaluation.Evaluate(ref board);
            }

            // Get features for the side to move
            float[] features = _featureEncoder.GetFeatures(ref board, board.SideToMove);

            // Forward pass through the network
            float[] hidden1 = new float[HiddenSize1];
            float[] hidden2 = new float[HiddenSize2];
            float[] output1 = new float[HiddenSize2];
            float[] output2 = new float[1];

            // Layer 1: Input -> Hidden1 (with ReLU)
            MatrixVectorMultiply(_featureTransformerWeights1, features, hidden1);
            AddBias(hidden1, _featureTransformerBias1);
            ApplyReLU(hidden1);

            // Layer 2: Hidden1 -> Hidden2 (with ReLU)
            MatrixVectorMultiply(_featureTransformerWeights2, hidden1, hidden2);
            AddBias(hidden2, _featureTransformerBias2);
            ApplyReLU(hidden2);

            // Layer 3: Hidden2 -> Hidden2 (with ReLU)
            MatrixVectorMultiply(_outputWeights1, hidden2, output1);
            AddBias(output1, _outputBias1);
            ApplyReLU(output1);

            // Layer 4: Hidden2 -> Output (with Tanh)
            MatrixVectorMultiply(_outputWeights2, output1, output2);
            AddBias(output2, _outputBias2);
            float evaluation = (float)Math.Tanh(output2[0]);

            // Scale back to centipawns
            int evalCp = (int)(evaluation * EvalScale);

            // Return from side to move perspective (already handled by feature encoding)
            return evalCp;
        }

        /// <summary>
        /// Matrix-vector multiplication
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void MatrixVectorMultiply(float[,] matrix, float[] vector, float[] result)
        {
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            for (int i = 0; i < rows; i++)
            {
                float sum = 0;
                for (int j = 0; j < cols; j++)
                {
                    sum += matrix[i, j] * vector[j];
                }
                result[i] = sum;
            }
        }

        /// <summary>
        /// Add bias to vector
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void AddBias(float[] vector, float[] bias)
        {
            for (int i = 0; i < vector.Length; i++)
            {
                vector[i] += bias[i];
            }
        }

        /// <summary>
        /// Apply ReLU activation
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ApplyReLU(float[] vector)
        {
            for (int i = 0; i < vector.Length; i++)
            {
                if (vector[i] < 0) vector[i] = 0;
            }
        }

        /// <summary>
        /// Check if NNUE is loaded and ready
        /// </summary>
        public bool IsLoaded => _isLoaded;
    }

    /// <summary>
    /// HalfKP feature encoder for NNUE
    /// </summary>
    public class HalfKPFeatureEncoder
    {
        private const int NumSquares = 64;
        private const int NumPieceTypes = 6;
        private const int NumColors = 2;

        /// <summary>
        /// Get HalfKP features for a position
        /// </summary>
        public float[] GetFeatures(ref Board board, Color sideToMove)
        {
            float[] features = new float[768];

            // Find king position
            ulong kingBitboard = sideToMove == Color.White ? board.WhiteKing : board.BlackKing;
            if (kingBitboard == 0) return features;

            int kingSquare = BitboardConstants.BitScanForward(kingBitboard);

            // Mirror for black's perspective
            if (sideToMove == Color.Black)
            {
                kingSquare = MirrorSquare(kingSquare);
            }

            // Encode all pieces relative to king
            EncodeColorPieces(ref board, sideToMove, kingSquare, features, true);  // Own pieces
            EncodeColorPieces(ref board, sideToMove == Color.White ? Color.Black : Color.White,
                            kingSquare, features, false); // Enemy pieces

            return features;
        }

        /// <summary>
        /// Encode pieces of one color
        /// </summary>
        private void EncodeColorPieces(ref Board board, Color pieceColor, int kingSquare,
                                      float[] features, bool ownPieces)
        {
            int colorOffset = ownPieces ? 0 : 1;

            // Pawns
            EncodePieceType(board.GetPieceBitboard(PieceType.Pawn, pieceColor),
                           0, kingSquare, colorOffset, features, pieceColor != board.SideToMove);

            // Knights
            EncodePieceType(board.GetPieceBitboard(PieceType.Knight, pieceColor),
                           1, kingSquare, colorOffset, features, pieceColor != board.SideToMove);

            // Bishops
            EncodePieceType(board.GetPieceBitboard(PieceType.Bishop, pieceColor),
                           2, kingSquare, colorOffset, features, pieceColor != board.SideToMove);

            // Rooks
            EncodePieceType(board.GetPieceBitboard(PieceType.Rook, pieceColor),
                           3, kingSquare, colorOffset, features, pieceColor != board.SideToMove);

            // Queens
            EncodePieceType(board.GetPieceBitboard(PieceType.Queen, pieceColor),
                           4, kingSquare, colorOffset, features, pieceColor != board.SideToMove);

            // King (skip own king)
            if (!ownPieces)
            {
                EncodePieceType(board.GetPieceBitboard(PieceType.King, pieceColor),
                               5, kingSquare, colorOffset, features, pieceColor != board.SideToMove);
            }
        }

        /// <summary>
        /// Encode a specific piece type
        /// </summary>
        private void EncodePieceType(ulong bitboard, int pieceTypeIdx, int kingSquare,
                                   int colorOffset, float[] features, bool mirrorForBlack)
        {
            while (bitboard != 0)
            {
                int square = BitboardConstants.BitScanForward(bitboard);
                bitboard = BitboardConstants.ClearBit(bitboard, square);

                // Mirror square for black's perspective
                if (mirrorForBlack)
                {
                    square = MirrorSquare(square);
                }

                // Calculate feature index
                // HalfKP encoding: king_square * 10 * 64 + piece_color * 6 * 64 + piece_type * 64 + square
                int featureIdx = kingSquare * 10 * 64 +
                               colorOffset * 6 * 64 +
                               pieceTypeIdx * 64 +
                               square;

                if (featureIdx >= 0 && featureIdx < 768)
                {
                    features[featureIdx] = 1.0f;
                }
            }
        }

        /// <summary>
        /// Mirror square vertically (for black's perspective)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private int MirrorSquare(int square)
        {
            return square ^ 56; // Flip rank
        }
    }
}