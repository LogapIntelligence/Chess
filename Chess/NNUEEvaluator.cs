using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Chess
{
    /// <summary>
    /// Global NNUE configuration
    /// </summary>
    public static class NNUEConfig
    {
        // Set your NNUE file path here
        public static string NNUEPath;

        // Enable/disable NNUE evaluation
        public static bool UseNNUE = true;
    }

    /// <summary>
    /// NNUE (Efficiently Updatable Neural Network) evaluator for chess positions
    /// Compatible with the NNUE format generated by the Python training system
    /// </summary>
    public class NNUEEvaluator : INNUEEvaluator
    {
        // Network architecture constants (must match your training configuration)
        private const int InputSize = 768;      // HalfKP features
        private const int HiddenSize1 = 256;    // First hidden layer
        private const int HiddenSize2 = 32;     // Second hidden layer
        private const float EvalScale = 361.0f; // Scaling factor from training

        // Network weights and biases
        private float[,] _featureTransformerWeights1;
        private float[] _featureTransformerBias1;
        private float[,] _featureTransformerWeights2;
        private float[] _featureTransformerBias2;
        private float[,] _outputWeights1;
        private float[] _outputBias1;
        private float[,] _outputWeights2;
        private float[] _outputBias2;

        // Feature encoding
        private readonly HalfKPFeatureEncoder _featureEncoder;

        // Path to NNUE file
        private readonly string _nnuePath;
        private bool _isLoaded = false;

        public NNUEEvaluator(string nnuePath)
        {
            _nnuePath = nnuePath;
            _featureEncoder = new HalfKPFeatureEncoder();
            LoadNNUE();
        }

        /// <summary>
        /// Load NNUE weights from file
        /// </summary>
        private void LoadNNUE()
        {
            try
            {
                var fileInfo = new FileInfo(_nnuePath);
                Console.WriteLine($"NNUE file size: {fileInfo.Length} bytes");

                using (var fs = new FileStream(_nnuePath, FileMode.Open, FileAccess.Read))
                using (var br = new BinaryReader(fs))
                {
                    long startPos = fs.Position;

                    // Read and verify header
                    byte[] magic = br.ReadBytes(4);
                    string magicStr = Encoding.ASCII.GetString(magic);
                    Console.WriteLine($"Magic bytes: {BitConverter.ToString(magic)} ('{magicStr}')");

                    if (magicStr != "NNUE")
                    {
                        throw new InvalidOperationException($"Invalid NNUE file format. Expected 'NNUE', got '{magicStr}'");
                    }

                    uint versionHash = br.ReadUInt32();
                    uint architectureHash = br.ReadUInt32();
                    Console.WriteLine($"Version hash: 0x{versionHash:X8}");
                    Console.WriteLine($"Architecture hash: 0x{architectureHash:X8}");

                    // Check if this looks like a description length or the start of weights
                    long posBeforeDesc = fs.Position;
                    uint possibleDescLength = br.ReadUInt32();

                    // If the value looks suspiciously large or the file doesn't have enough bytes for it,
                    // it's probably not a description length but the start of the weights
                    bool hasDescription = possibleDescLength < 1000 && fs.Position + possibleDescLength <= fs.Length;

                    if (hasDescription)
                    {
                        try
                        {
                            // Try to read as description
                            byte[] descBytes = br.ReadBytes((int)possibleDescLength);
                            string desc = Encoding.UTF8.GetString(descBytes);

                            // Check if it's actually text
                            bool isText = true;
                            foreach (char c in desc)
                            {
                                if (char.IsControl(c) && c != '\n' && c != '\r' && c != '\t')
                                {
                                    isText = false;
                                    break;
                                }
                            }

                            if (isText)
                            {
                                Console.WriteLine($"Description length: {possibleDescLength}");
                                Console.WriteLine($"Description: {desc}");
                            }
                            else
                            {
                                // Not text, probably weights - rewind
                                fs.Seek(posBeforeDesc, SeekOrigin.Begin);
                                Console.WriteLine("No description field detected, proceeding to weights");
                            }
                        }
                        catch
                        {
                            // Failed to read description, assume no description
                            fs.Seek(posBeforeDesc, SeekOrigin.Begin);
                            Console.WriteLine("No description field detected, proceeding to weights");
                        }
                    }
                    else
                    {
                        // No description, rewind to read this as part of weights
                        fs.Seek(posBeforeDesc, SeekOrigin.Begin);
                        Console.WriteLine("No description field detected, proceeding to weights");
                    }

                    // Calculate expected file size
                    long expectedSize = CalculateExpectedFileSize();
                    long currentPos = fs.Position;
                    long remainingBytes = fs.Length - currentPos;

                    Console.WriteLine($"Current position: {currentPos}");
                    Console.WriteLine($"Remaining bytes: {remainingBytes}");
                    Console.WriteLine($"Expected weights size: {expectedSize - currentPos}");

                    if (remainingBytes < expectedSize - currentPos)
                    {
                        throw new InvalidOperationException($"File too small for network weights. Need {expectedSize - currentPos} more bytes, but only {remainingBytes} available");
                    }

                    // Allocate arrays
                    _featureTransformerWeights1 = new float[HiddenSize1, InputSize];
                    _featureTransformerBias1 = new float[HiddenSize1];
                    _featureTransformerWeights2 = new float[HiddenSize2, HiddenSize1];
                    _featureTransformerBias2 = new float[HiddenSize2];
                    _outputWeights1 = new float[HiddenSize2, HiddenSize2];
                    _outputBias1 = new float[HiddenSize2];
                    _outputWeights2 = new float[1, HiddenSize2];
                    _outputBias2 = new float[1];

                    // Read feature transformer layer 1
                    Console.WriteLine("Reading layer 1 weights...");
                    ReadWeights(br, _featureTransformerWeights1);
                    ReadBias(br, _featureTransformerBias1);

                    // Read feature transformer layer 2
                    Console.WriteLine("Reading layer 2 weights...");
                    ReadWeights(br, _featureTransformerWeights2);
                    ReadBias(br, _featureTransformerBias2);

                    // Read output layer 1
                    Console.WriteLine("Reading output layer 1 weights...");
                    ReadWeights(br, _outputWeights1);
                    ReadBias(br, _outputBias1);

                    // Read output layer 2
                    Console.WriteLine("Reading output layer 2 weights...");
                    ReadWeights(br, _outputWeights2);
                    ReadBias(br, _outputBias2);

                    long finalPos = fs.Position;
                    Console.WriteLine($"Read {finalPos - startPos} bytes total");
                    Console.WriteLine($"Bytes remaining in file: {fs.Length - finalPos}");

                    _isLoaded = true;
                    Console.WriteLine("NNUE model loaded successfully!");
                }
            }
            catch (FileNotFoundException)
            {
                Console.WriteLine($"NNUE file not found: {_nnuePath}");
                Console.WriteLine("Falling back to classical evaluation");
            }
            catch (EndOfStreamException ex)
            {
                Console.WriteLine($"Error: Reached end of file while reading NNUE");
                Console.WriteLine($"Details: {ex.Message}");
                Console.WriteLine("The NNUE file appears to be truncated or in a different format");
                Console.WriteLine("Falling back to classical evaluation");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error loading NNUE: {ex.Message}");
                Console.WriteLine($"Exception type: {ex.GetType().Name}");
                Console.WriteLine("Falling back to classical evaluation");
            }
        }

        /// <summary>
        /// Calculate expected file size based on network architecture
        /// </summary>
        private long CalculateExpectedFileSize()
        {
            long size = 0;

            // Header: magic (4) + version (4) + architecture (4) + description length (4)
            size += 16;

            // Description (variable, but we'll estimate)
            size += 100; // Rough estimate

            // Layer 1: weights + bias
            size += HiddenSize1 * InputSize * 4; // weights as floats
            size += HiddenSize1 * 4; // bias as floats

            // Layer 2: weights + bias
            size += HiddenSize2 * HiddenSize1 * 4;
            size += HiddenSize2 * 4;

            // Output layer 1: weights + bias
            size += HiddenSize2 * HiddenSize2 * 4;
            size += HiddenSize2 * 4;

            // Output layer 2: weights + bias
            size += 1 * HiddenSize2 * 4;
            size += 1 * 4;

            return size;
        }

        /// <summary>
        /// Read weight matrix from binary reader with validation
        /// </summary>
        private void ReadWeights(BinaryReader br, float[,] weights)
        {
            int rows = weights.GetLength(0);
            int cols = weights.GetLength(1);
            int totalElements = rows * cols;

            Console.WriteLine($"  Reading {rows}x{cols} = {totalElements} weights ({totalElements * 4} bytes)");

            try
            {
                for (int i = 0; i < rows; i++)
                {
                    for (int j = 0; j < cols; j++)
                    {
                        weights[i, j] = br.ReadSingle();

                        // Sanity check for reasonable weight values
                        if (float.IsNaN(weights[i, j]) || float.IsInfinity(weights[i, j]) ||
                            Math.Abs(weights[i, j]) > 100.0f)
                        {
                            Console.WriteLine($"  Warning: Unusual weight value at [{i},{j}]: {weights[i, j]}");
                        }
                    }
                }
            }
            catch (EndOfStreamException)
            {
                throw new EndOfStreamException($"Unexpected end of file while reading weights. Expected {totalElements} values.");
            }
        }

        /// <summary>
        /// Read bias vector from binary reader with validation
        /// </summary>
        private void ReadBias(BinaryReader br, float[] bias)
        {
            Console.WriteLine($"  Reading {bias.Length} bias values ({bias.Length * 4} bytes)");

            try
            {
                for (int i = 0; i < bias.Length; i++)
                {
                    bias[i] = br.ReadSingle();

                    // Sanity check for reasonable bias values
                    if (float.IsNaN(bias[i]) || float.IsInfinity(bias[i]) ||
                        Math.Abs(bias[i]) > 100.0f)
                    {
                        Console.WriteLine($"  Warning: Unusual bias value at [{i}]: {bias[i]}");
                    }
                }
            }
            catch (EndOfStreamException)
            {
                throw new EndOfStreamException($"Unexpected end of file while reading bias. Expected {bias.Length} values.");
            }
        }

        /// <summary>
        /// Evaluate a chess position using NNUE
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Evaluate(ref Board board)
        {
            // Fall back to classical evaluation if NNUE not loaded
            if (!_isLoaded)
            {
                return Evaluation.Evaluate(ref board);
            }

            // Get features for the side to move
            float[] features = _featureEncoder.GetFeatures(ref board, board.SideToMove);

            // Forward pass through the network
            float[] hidden1 = new float[HiddenSize1];
            float[] hidden2 = new float[HiddenSize2];
            float[] output1 = new float[HiddenSize2];
            float[] output2 = new float[1];

            // Layer 1: Input -> Hidden1 (with ReLU)
            MatrixVectorMultiply(_featureTransformerWeights1, features, hidden1);
            AddBias(hidden1, _featureTransformerBias1);
            ApplyReLU(hidden1);

            // Layer 2: Hidden1 -> Hidden2 (with ReLU)
            MatrixVectorMultiply(_featureTransformerWeights2, hidden1, hidden2);
            AddBias(hidden2, _featureTransformerBias2);
            ApplyReLU(hidden2);

            // Layer 3: Hidden2 -> Hidden2 (with ReLU)
            MatrixVectorMultiply(_outputWeights1, hidden2, output1);
            AddBias(output1, _outputBias1);
            ApplyReLU(output1);

            // Layer 4: Hidden2 -> Output (with Tanh)
            MatrixVectorMultiply(_outputWeights2, output1, output2);
            AddBias(output2, _outputBias2);
            float evaluation = (float)Math.Tanh(output2[0]);

            // Scale back to centipawns
            int evalCp = (int)(evaluation * EvalScale);

            // Return from side to move perspective (already handled by feature encoding)
            return evalCp;
        }

        /// <summary>
        /// Matrix-vector multiplication
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void MatrixVectorMultiply(float[,] matrix, float[] vector, float[] result)
        {
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            for (int i = 0; i < rows; i++)
            {
                float sum = 0;
                for (int j = 0; j < cols; j++)
                {
                    sum += matrix[i, j] * vector[j];
                }
                result[i] = sum;
            }
        }

        /// <summary>
        /// Add bias to vector
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void AddBias(float[] vector, float[] bias)
        {
            for (int i = 0; i < vector.Length; i++)
            {
                vector[i] += bias[i];
            }
        }

        /// <summary>
        /// Apply ReLU activation
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ApplyReLU(float[] vector)
        {
            for (int i = 0; i < vector.Length; i++)
            {
                if (vector[i] < 0) vector[i] = 0;
            }
        }

        /// <summary>
        /// Check if NNUE is loaded and ready
        /// </summary>
        public bool IsLoaded => _isLoaded;
    }

    /// <summary>
    /// HalfKP feature encoder for NNUE
    /// </summary>
    public class HalfKPFeatureEncoder
    {
        private const int NumSquares = 64;
        private const int NumPieceTypes = 6;
        private const int NumColors = 2;

        /// <summary>
        /// Get HalfKP features for a position
        /// </summary>
        public float[] GetFeatures(ref Board board, Color sideToMove)
        {
            float[] features = new float[768];

            // Find king position
            ulong kingBitboard = sideToMove == Color.White ? board.WhiteKing : board.BlackKing;
            if (kingBitboard == 0) return features;

            int kingSquare = BitboardConstants.BitScanForward(kingBitboard);

            // Mirror for black's perspective
            if (sideToMove == Color.Black)
            {
                kingSquare = MirrorSquare(kingSquare);
            }

            // Encode all pieces relative to king
            EncodeColorPieces(ref board, sideToMove, kingSquare, features, true);  // Own pieces
            EncodeColorPieces(ref board, sideToMove == Color.White ? Color.Black : Color.White,
                            kingSquare, features, false); // Enemy pieces

            return features;
        }

        /// <summary>
        /// Encode pieces of one color
        /// </summary>
        private void EncodeColorPieces(ref Board board, Color pieceColor, int kingSquare,
                                      float[] features, bool ownPieces)
        {
            int colorOffset = ownPieces ? 0 : 1;

            // Pawns
            EncodePieceType(board.GetPieceBitboard(PieceType.Pawn, pieceColor),
                           0, kingSquare, colorOffset, features, pieceColor != board.SideToMove);

            // Knights
            EncodePieceType(board.GetPieceBitboard(PieceType.Knight, pieceColor),
                           1, kingSquare, colorOffset, features, pieceColor != board.SideToMove);

            // Bishops
            EncodePieceType(board.GetPieceBitboard(PieceType.Bishop, pieceColor),
                           2, kingSquare, colorOffset, features, pieceColor != board.SideToMove);

            // Rooks
            EncodePieceType(board.GetPieceBitboard(PieceType.Rook, pieceColor),
                           3, kingSquare, colorOffset, features, pieceColor != board.SideToMove);

            // Queens
            EncodePieceType(board.GetPieceBitboard(PieceType.Queen, pieceColor),
                           4, kingSquare, colorOffset, features, pieceColor != board.SideToMove);

            // King (skip own king)
            if (!ownPieces)
            {
                EncodePieceType(board.GetPieceBitboard(PieceType.King, pieceColor),
                               5, kingSquare, colorOffset, features, pieceColor != board.SideToMove);
            }
        }

        /// <summary>
        /// Encode a specific piece type
        /// </summary>
        private void EncodePieceType(ulong bitboard, int pieceTypeIdx, int kingSquare,
                                   int colorOffset, float[] features, bool mirrorForBlack)
        {
            while (bitboard != 0)
            {
                int square = BitboardConstants.BitScanForward(bitboard);
                bitboard = BitboardConstants.ClearBit(bitboard, square);

                // Mirror square for black's perspective
                if (mirrorForBlack)
                {
                    square = MirrorSquare(square);
                }

                // Calculate feature index
                // HalfKP encoding: king_square * 10 * 64 + piece_color * 6 * 64 + piece_type * 64 + square
                int featureIdx = kingSquare * 10 * 64 +
                               colorOffset * 6 * 64 +
                               pieceTypeIdx * 64 +
                               square;

                if (featureIdx >= 0 && featureIdx < 768)
                {
                    features[featureIdx] = 1.0f;
                }
            }
        }

        /// <summary>
        /// Mirror square vertically (for black's perspective)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private int MirrorSquare(int square)
        {
            return square ^ 56; // Flip rank
        }
    }
}