@model IEnumerable<Database.Models.Batch>

@{
    ViewData["Title"] = "Dashboard";
}

<div class="container mx-auto">
    <!-- Stats -->
    <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-6">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 class="text-lg font-medium text-gray-400">Total Games</h3>
            <p class="text-3xl font-bold text-white" id="totalGames">@ViewBag.TotalGames</p>
        </div>
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 class="text-lg font-medium text-gray-400">Total Moves</h3>
            <p class="text-3xl font-bold text-white" id="totalMoves">@ViewBag.TotalMoves</p>
        </div>
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 class="text-lg font-medium text-gray-400">Active Generations</h3>
            <p class="text-3xl font-bold text-white" id="activeGenerations">@ViewBag.ActiveGenerations</p>
        </div>
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
            <h3 class="text-lg font-medium text-gray-400">Queue Length</h3>
            <p class="text-3xl font-bold text-white" id="queueLength">0</p>
        </div>
    </div>

    <!-- Live Games Container -->
    <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
        <h2 class="text-xl font-semibold mb-4 text-white">Live Game Generation</h2>
        <div id="liveGamesContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
            <!-- Game cards will be dynamically added here -->
        </div>
        <div id="noActiveGames" class="text-center py-10 hidden">
            <p class="text-gray-400">No active game generations.</p>
        </div>
    </div>
</div>

@section Scripts {
    <style>
        .chess-square {
            position: absolute;
        }

        .chess-piece {
            position: absolute;
            width: 100%;
            height: 100%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .eval-bar {
            height: 20px;
            position: relative;
            background: linear-gradient(to right, #1a1a1a 0%, #1a1a1a 50%, #f0f0f0 50%, #f0f0f0 100%);
            border: 1px solid #444;
            border-radius: 2px;
        }

        .eval-indicator {
            position: absolute;
            top: -2px;
            width: 4px;
            height: 24px;
            background: #ef4444;
            border-radius: 2px;
            transition: left 0.3s ease;
            box-shadow: 0 0 4px rgba(0,0,0,0.5);
        }

        .game-card {
            transition: all 0.3s ease;
        }

            .game-card.completed {
                opacity: 0.7;
                transform: scale(0.98);
            }

            .game-card .board-container {
                position: relative;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            }

        .move-counter {
            font-variant-numeric: tabular-nums;
        }
        /* Pulse animation for new moves */
        @@keyframes pulse {
            0%

        {
            opacity: 1;
        }

        50% {
            opacity: 0.6;
        }

        100% {
            opacity: 1;
        }

        }

        .new-move {
            animation: pulse 0.5s ease;
        }
    </style>

    <script>
        // Game state management
        const activeGames = new Map();
        let pieceImages = {};

        // Preload piece images
        const pieceTypes = {
            'K': 'kl', 'Q': 'ql', 'R': 'rl', 'B': 'bl', 'N': 'nl', 'P': 'pl',
            'k': 'kd', 'q': 'qd', 'r': 'rd', 'b': 'bd', 'n': 'nd', 'p': 'pd'
        };

        // Initialize SignalR handlers
        dashboardConnection.on("UpdateDashboardStats", (stats) => {
            document.getElementById('totalGames').textContent = stats.totalGames.toLocaleString();
            document.getElementById('totalMoves').textContent = stats.totalMoves.toLocaleString();
            document.getElementById('activeGenerations').textContent = stats.activeGenerations;
            document.getElementById('queueLength').textContent = stats.queueLength || 0;
        });

        dashboardConnection.on("InitializeActiveBatches", (batches) => {
            // Clear existing games
            activeGames.clear();
            document.getElementById('liveGamesContainer').innerHTML = '';

            // Hide/show no games message
            document.getElementById('noActiveGames').classList.toggle('hidden', batches.length > 0);
        });

        dashboardConnection.on("GameStarted", (data) => {
            createGameCard(data.tempGameId, data);
        });

        dashboardConnection.on("NewMove", (data) => {
            updateGameCard(data.tempGameId, data);
        });

        dashboardConnection.on("GameComplete", (data) => {
            markGameComplete(data.tempGameId, data);
        });

        dashboardConnection.on("ReceiveProgressUpdate", (data) => {
            // Update batch progress if needed
            updateBatchProgress(data.batchId, data);
        });

        // Create a new game card
        function createGameCard(gameId, data) {
            const container = document.getElementById('liveGamesContainer');
            document.getElementById('noActiveGames').classList.add('hidden');

            const card = document.createElement('div');
            card.id = `game-${gameId}`;
            card.className = 'game-card bg-gray-700 rounded-lg p-4 shadow-lg';
            card.innerHTML = `
                <div class="mb-2">
                    <h4 class="text-white font-semibold text-sm truncate" title="${data.engineName}">${data.engineName}</h4>
                    <div class="flex justify-between text-xs">
                        <span class="text-gray-400">Time: ${data.movetime}ms</span>
                        <span class="text-gray-400">Batch: ${data.batchId}</span>
                    </div>
                </div>
                <div class="board-container bg-gray-600 rounded mb-2 overflow-hidden" style="width: 100%; aspect-ratio: 1;">
                    <div id="board-${gameId}" class="relative w-full h-full">
                        <!-- Mini chess board will be rendered here -->
                    </div>
                </div>
                <div class="move-info text-center mb-2">
                    <span class="text-gray-300 text-sm">Move <span id="move-${gameId}" class="move-counter font-mono">0</span></span>
                </div>
                <div class="eval-bar rounded overflow-hidden">
                    <div id="eval-${gameId}" class="eval-indicator" style="left: 50%;"></div>
                </div>
                <div class="eval-text text-center mt-1">
                    <span id="eval-text-${gameId}" class="text-gray-300 text-xs font-mono">0.00</span>
                </div>
            `;
            container.appendChild(card);

            // Initialize board with starting position
            renderMiniBoard(gameId, "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");

            activeGames.set(gameId, { moveCount: 0, evaluation: 0 });
        }

        // Update batch progress
        function updateBatchProgress(batchId, data) {
            // This can be used to update overall batch progress indicators if needed
            console.log(`Batch ${batchId}: ${data.currentGames}/${data.totalGames}`);
        }

        // Update game card with new move
        function updateGameCard(gameId, data) {
            if (!activeGames.has(gameId)) return;

            const game = activeGames.get(gameId);
            game.moveCount = data.moveNumber;
            game.evaluation = data.evaluation;

            // Add pulse animation to card
            const card = document.getElementById(`game-${gameId}`);
            if (card) {
                card.classList.add('new-move');
                setTimeout(() => card.classList.remove('new-move'), 500);
            }

            // Update board
            renderMiniBoard(gameId, data.fen);

            // Update move counter
            const moveEl = document.getElementById(`move-${gameId}`);
            if (moveEl) moveEl.textContent = data.moveNumber;

            // Update evaluation bar and text
            updateEvaluation(gameId, data.evaluation);

            // If game has a result, mark it complete
            if (data.gameResult && data.gameResult !== '*') {
                markGameComplete(gameId, { result: data.gameResult });
            }
        }

        // Mark game as complete
        function markGameComplete(gameId, data) {
            const card = document.getElementById(`game-${gameId}`);
            if (card) {
                card.classList.add('completed');

                // Add result indicator
                const resultDiv = document.createElement('div');
                resultDiv.className = 'text-center mt-2';
                const resultClass = data.result === '1-0' ? 'text-white' :
                                   data.result === '0-1' ? 'text-gray-900 bg-gray-300 px-2 rounded' :
                                   'text-gray-400';
                resultDiv.innerHTML = `<span class="font-semibold ${resultClass}">${data.result}</span>`;
                card.appendChild(resultDiv);

                // Remove from active games after a delay
                setTimeout(() => {
                    card.style.transition = 'opacity 0.5s, transform 0.5s';
                    card.style.opacity = '0';
                    card.style.transform = 'scale(0.9)';

                    setTimeout(() => {
                        card.remove();
                        activeGames.delete(gameId);

                        // Show no games message if empty
                        if (activeGames.size === 0) {
                            document.getElementById('noActiveGames').classList.remove('hidden');
                        }
                    }, 500);
                }, 5000);
            }
        }

        // Render mini chess board with actual SVG pieces
        function renderMiniBoard(gameId, fen) {
            const boardEl = document.getElementById(`board-${gameId}`);
            if (!boardEl) return;

            boardEl.innerHTML = '';

            // Create board squares
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.className = 'chess-square';
                    square.style.width = '12.5%';
                    square.style.height = '12.5%';
                    square.style.left = (c * 12.5) + '%';
                    square.style.top = (r * 12.5) + '%';
                    square.style.background = (r + c) % 2 === 0 ? '#b58863' : '#f0d9b5';
                    boardEl.appendChild(square);
                }
            }

            // Parse FEN and place pieces
            const fenParts = fen.split(' ');
            const position = fenParts[0];
            let row = 7, col = 0;

            for (let char of position) {
                if (char === '/') {
                    row--;
                    col = 0;
                } else if (char >= '1' && char <= '8') {
                    col += parseInt(char);
                } else if (pieceTypes[char]) {
                    const piece = document.createElement('div');
                    piece.className = 'chess-piece';
                    piece.style.width = '12.5%';
                    piece.style.height = '12.5%';
                    piece.style.left = (col * 12.5) + '%';
                    piece.style.top = ((7 - row) * 12.5) + '%';
                    piece.style.backgroundImage = `url('/img/Chess_${pieceTypes[char]}t45.svg')`;
                    boardEl.appendChild(piece);
                    col++;
                }
            }
        }

        // Update evaluation bar with smooth transitions
        function updateEvaluation(gameId, evaluation) {
            const evalBar = document.getElementById(`eval-${gameId}`);
            const evalText = document.getElementById(`eval-text-${gameId}`);

            if (!evalBar || !evalText) return;

            // Handle mate scores
            if (Math.abs(evaluation) >= 9999) {
                evalBar.style.left = evaluation > 0 ? '100%' : '0%';
                evalText.textContent = evaluation > 0 ? 'M+' : 'M-';
                evalText.className = evaluation > 0 ? 'text-white text-xs font-bold' : 'text-gray-900 text-xs font-bold bg-gray-300 px-1 rounded';
                return;
            }

            // Clamp evaluation to -10 to 10 for display
            const clampedEval = Math.max(-10, Math.min(10, evaluation));

            // Convert to percentage (0% = -10, 50% = 0, 100% = +10)
            const percentage = ((clampedEval + 10) / 20) * 100;
            evalBar.style.left = percentage + '%';

            // Update text with appropriate styling
            evalText.textContent = evaluation > 10 ? '+10.00' :
                                  evaluation < -10 ? '-10.00' :
                                  evaluation.toFixed(2);

            if (evaluation > 1) {
                evalText.className = 'text-white text-xs font-mono font-semibold';
            } else if (evaluation < -1) {
                evalText.className = 'text-gray-900 text-xs font-mono bg-gray-300 px-1 rounded';
            } else if (evaluation > 0.5) {
                evalText.className = 'text-white text-xs font-mono';
            } else if (evaluation < -0.5) {
                evalText.className = 'text-gray-400 text-xs font-mono';
            } else {
                evalText.className = 'text-gray-300 text-xs font-mono';
            }
        }

        // Batch optimization for rapid updates
        let updateQueue = [];
        let updateTimer = null;

        function queueUpdate(updateFn) {
            updateQueue.push(updateFn);

            if (!updateTimer) {
                updateTimer = setTimeout(() => {
                    const updates = updateQueue.splice(0, updateQueue.length);
                    updates.forEach(fn => fn());
                    updateTimer = null;
                }, 16); // ~60fps
            }
        }

        // Override update functions to use queue for rapid updates
        const originalUpdateGameCard = updateGameCard;
        updateGameCard = function(gameId, data) {
            queueUpdate(() => originalUpdateGameCard(gameId, data));
        };
    </script>
}